# 设计文档

## 编译器总体设计

此编译器为BUAA2022编译原理课程作业。我使用java来开发编译器，下面是我的项目结构

```
----src\
    |----back\ 后端文件夹
    |    |----instruction\ 定义汇编代码类
    |    |    |----MipsInstruction.java 汇编代码的基类，其余汇编代码类都继承这个类
    |    |----Mips.java 存储所有的汇编码并负责输出
    |    |----optimize\ 后端相关优化
    |    |----RegisterMap.java 寄存器分配类
    |    |----store\ 内存管理相关包
    |    |----Translator.java 后端翻译类，将中间代码翻译成汇编码
    |----Compiler.java 编译器的运行类
    |----error\ 错误处理相关文件夹
    |----front\ 前端文件夹
    |    |----Lexer.java 词法分析器，将输入的文本转换为token
    |    |----Paser.java 语法分析器，将输入的token表转化为语法树
    |----middle\ 中间代码生成文件夹
    |    |----IRBuilder.java 中间代码分析类，解析语法树生成中间代码
    |    |----middlecode\ 定义各种中间代码类
    |    |----MiddleCode.java 存储所有的中间代码并负责提供给Translator进行解析
    |    |----optimize\ 中间代码相关优化
    |    |----symboltable\ 符号表相关包
```

## 词法分析设计

### 编码前的设计

词法分析有两大难点，第一是注释的删除，第二是将源程序转化为token序列。我才用将源程序逐行读入保存为一个字符串数组，在调用词法分析程序之前先遍历一遍字符串数组将注释删除，然后再二次遍历获取token序列的设计。删除注释采用的是标记删除的做法，逐个字符读入分析出 需要删除的注释的其实行数与位置和结束行数与位置，再进行删除。词法分析采用逐个字符解析的做法，对字符流进行逐个读入并判断应采用的解析函数，对于ident或者保留关键词，采取缓存字符直到读入非法字符之后获取缓存字符并解析的做法。最终得到所需的token序列并保存起来，用于输出或者提供给语法分析。

### 编码完成之后的修改

在错误处理部分添加了对format-string的错误检查，如果出错则添加到错误表。

## 语法分析设计

### 编码前的设计

采用递归下降法进行语法分析，并将结果以语法树的形式保存起来。对语法定义中的每个成分都设置了对应的解析方法，语法树则每个父节点按照将语法定义下其解析出来的下一层语法成分按顺序存入这一级节点的做法。采用巴斯克范式消除左递归后，使用提前偷窥进行判断应该对应的语法成分解析程序并组织成语法树，等待中间代码生成部分的使用。

语法树节点的设计

```java
public class PaserUnit {
    private boolean isEnd; // false is not end, true is end
    private Token token;
    private String Type;
    private ArrayList<PaserUnit> units;
    private String StmtType;
    private String PrimaryExpType;

    public PaserUnit(String Type, ArrayList<PaserUnit> units) { // 非终结语法成分
        this.isEnd = false;
        this.Type = Type;
        this.units = units;
    }

    public PaserUnit(Token token) { // token类型语法成分
        this.isEnd = true;
        this.token = token;
    }

    public PaserUnit(String Type, ArrayList<PaserUnit> units, String StmtType) { // stmt类型语法成分
        this.isEnd = false;
        this.Type = Type;
        this.units = units;
        this.StmtType = StmtType;
    }
```



### 编码完成之后的修改

在错误处理阶段，添加了对缺乏右小括号，右中括号和分号缺失的错误处理。使用的方式是当语法分析程序检测到这些符号的缺失是将错误信息保存到错误表，然后将对应的成分重新生成之后加入语法树，保证语法树的完整性与正确性，提供给后续中间代码生成的部分。

在中间代码生成阶段，添加了对stmt语句类型的额外保存，用于分辨该语法树节点对应的语句从而调用正确的生成函数。

## 错误处理设计：

### 编码前的设计

除了在上述词法分析部分和语法分析部分完成的错误处理之外，还有语义分析部分的错误处理。这里还涉及到了语法树的遍历，具体做法是对对应语法成分设计对应的遍历函数，通过遍历函数解析语法树的节点并调用该节点的下级节点的解析函数从而完成语法树的遍历。在遍历过程中负责生成符号表以及对应的符号，用于检查是否出错并提供给后续中间代码生成部分使用。具体方式是在遍历过程中保存当前符号表，如果遇到block则创建新的符号表并将该符号表设为当前符号表的子表，然后把该符号表设为当前符号表。在遇到使用ident定义时，在当前符号表中检查是否同名定义。在使用ident时自下而上的检索符号表，检查是否存在未定义错误。

### 编码完成之后的修改

在中间代码分析部分进行了大改，一开始符号仅保存了变量名，符号表仅保存了变量。因为后续代码生成需要使用数据存储相关的信息，所以给符号和符号表添加了相关的属性来获取数据存储的偏移位置和符号表对应的存储空间。同时在生成中间代码部分也进一步分析了语法成分，在这个过程中加入了其他语义分析相关的错误处理。

## 代码生成设计

### 中间代码设计

#### 变量与值

中间代码中将使用三种“值”类型：

1. 字值（`Item`）：用于存储值，可用作左值和右值
2. 址值（`Poniter`）：用于存储地址，可用作左值和右值。
3. 数值（`Immediate`）：直接表示数字，可用作右值，不可用作左值。字符串化后即为数值本身。

所有中间代码均直接操作这三种值，**以字值和址值为变量**。

因为字值和址值都是与符号表中的符号相对应的，于是我直接将符号表中的符号类Symbol进行扩展作为中间代码分析过程中需要使用的变量类。其中符号表中原本有的数组类型会在被调用的时候生成对应的址值类型的临时变量参与计算。立即数类型则是额外用单独的类来表示，与符号类共同实现操作数接口。

#### 中间代码设计

（类四元式）中间代码

|    指令名    |   Java 类名   |
| :----------: | :-----------: |
|   寻址操作   | AddressOffset |
|  基本块入口  |  BasicBlock   |
| 二元运算操作 |   BinaryOp    |
|    双分支    | BranchIfElse  |
|   函数调用   |     Call      |
|   写入操作   |     Input     |
|   跳转操作   |     Jump      |
|   指针操作   |   PointerOp   |
| 格式化字符串 |  PrintFormat  |
|   打印数值   |   PrintInt    |
|  打印字符串  |   PrintStr    |
|   返回操作   |    Return     |
| 一元运算操作 |    UnaryOp    |

### 生成mips汇编

使用Translator类对中间代码进行统一的翻译，这其中最重要的是寄存器的管理与分配。建立RegisterMap对寄存器进行统一的管理与分配。具体的分配策略是对所有公用的寄存器采用LRU算法进行分配，对于新的寄存器申请，当寄存器没有被分配完时从空余的寄存器里分配一个空闲寄存器，当寄存器池已满时，把满足“最近最少使用”的数据从寄存器中释放出去，然后将该寄存器用于新的申请。当进行跳转时释放所有的寄存器并将变量写回。

## 代码优化设计

### 数据流use-def分析

在生成中间代码的过程中根据跳转与新block的产生来划分基本块。在将中间代码翻译为汇编码时，当进入一个基本块，先遍历基本块中的所有变量，并一一记录定义使用情况。在翻译的过程中更新每个变量的使用情况，当最后一次使用之后解立刻将它从寄存器池中释放。

### 乘除优化

遍历中间代码，对于使用2的幂次的立即数进行乘除运算的中间代码，用移位运算进行替代，提高运算效率。

### 死代码删除

分为两步进行。首先将跳转语句后面的指令（属于死代码，无法被执行到）删除。然后优化掉没用的跳转，如果一个跳转跳到下一个基本块，且没有其他来源可以跳到当前跳转的目标基本块，则将跳转语句去掉，直接和目标基本块合并。先 BFS 遍历，对每个基本块记录其有几个来源，再次遍历所有的基本块并合并符合条件的基本块。

